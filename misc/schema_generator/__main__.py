from .config import Config
from .types import Spec
from typing import List, Tuple
from textwrap import dedent

import keyword
import sys
import os

from adaptix import Retort
from adaptix.struct_path import ExcPathRenderer
from json import loads
from pathlib import Path

match sys.argv:
    case [_, output_file]:
        out_fp = open(output_file, "w")
        out_fp.write(
            dedent(
                """
                # This file is autogenerated, do not edit it by hand
                from __future__ import annotations
                from dataclasses import dataclass
                from typing import List, Optional
                from enum import Enum
                """
            )
        )

    case [f_path, *_]:
        print(f"{f_path} usage: {f_path} <output_file>", file=sys.stderr)
        sys.exit(1)

retort = Retort()

cur_dir = Path(__file__).parent
cfg_path = cur_dir / "cfg.json"
spec_path = cur_dir.parent / "telegram-bot-api-spec/api.json"


with ExcPathRenderer():
    with open(cfg_path) as fp:
        cfg = retort.load(loads(fp.read()), Config)

    with open(spec_path) as fp:
        data = loads(fp.read())
        spec = retort.load(data, Spec)

TS_MAPPINGS = {
    "String": "str",
    "Integer": "int",
    "Boolean": "bool",
    "Float": "float",
}
INDENT = "    "


def _parse_type(ts: str) -> str:
    ts = ts.strip()
    if ts in TS_MAPPINGS:
        return TS_MAPPINGS[ts]

    if (wo_prefix := ts.removeprefix("Array of ")) != ts:
        in_list = _parse_type(wo_prefix)
        return f"List[{in_list}]"
    return ts


def parse_type(ts: str, required: bool) -> str:
    res = _parse_type(ts)
    if required:
        return res
    return f"Optional[{res}] = None"


def build_union(tps: List[str], required: bool) -> str:
    match tps:
        case []:
            raise ValueError("What?")

        case [single_tp]:
            return parse_type(single_tp, required)
        case [*tps]:
            v = " |".join(map(_parse_type, tps))
            if required:
                return v
            return f"Optional[{v}] = None"
    raise NotImplementedError


def build_enum(name: str, fields: List[str | Tuple[str, str]]) -> str:
    out = ""
    for field in fields:
        if isinstance(field, str):
            out += f"{INDENT}{field.upper()} = {field!r}\n"
            continue
        python_name, rename = field

        out += f"{INDENT}{python_name.upper()} = {rename!r}\n"
    return f"class {name}(str, Enum):\n{out}"


for name, values in cfg.enums.types.items():
    out_fp.write(build_enum(name, values))
    out_fp.write("\n\n")

for tp_name, tp in spec.types.items():
    if not tp.fields:
        out_fp.write(
            f"@dataclass(slots=True)\nclass {tp.name}:\n{INDENT}pass\n\n"
        )
        continue

    out_fp.write(f"@dataclass(slots=True)\nclass {tp_name}:\n")
    tp.fields.sort(key=lambda f: not f.required)
    for field in tp.fields:
        name = field.name
        if name in keyword.kwlist:
            name += "_"

        qualname = f"{tp_name}.{field.name}"
        if (overrided := cfg.enums.override.get(qualname)) is not None:
            tp = overrided
        else:
            tp = build_union(field.types, field.required)

        if qualname in cfg.renames:
            name = cfg.renames[qualname]
        out_fp.write(f"{INDENT}{name}: {tp}\n")
    out_fp.write("\n\n")

out_fp.close()
os.system(f"black {output_file}")
